{"version":3,"sources":["../src/match-path.ts"],"names":["cache","cacheLimit","cacheCount","compilePath","path","options","cacheKey","end","strict","sensitive","pathCache","keys","regexp","result","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","match","exec","url","values","isExact","params","memo","key","index","name","computeRootMatch"],"mappings":"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","sourcesContent":["import pathToRegexp from 'path-to-regexp';\nimport { matchPathResult } from './globals';\n\nconst cache: { [key: string]: any } = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path: string, options: (pathToRegexp.RegExpOptions & pathToRegexp.ParseOptions)) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache: { [key: string]: any } = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) return pathCache[path];\n\n  const keys: pathToRegexp.Key[] = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = { regexp, keys };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\ninterface matchPathOptions {\n  path?: string,\n  exact?: boolean\n}\n\n/**\n * Public API for matching a URL pathname to a path.\n */\nfunction matchPath(pathname: string, options: (\n  pathToRegexp.RegExpOptions\n  & pathToRegexp.ParseOptions\n  & matchPathOptions\n  ) = {}): matchPathResult {\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = { path: options as any } as pathToRegexp.RegExpOptions;\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  const paths = ([] as string[]).concat(path || []);\n\n  return paths.reduce((matched: any, path: string) => {\n    if (!path && path !== '') return null;\n    if (matched) return matched;\n\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo: any, key: any, index: number) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport function computeRootMatch(pathname: string) {\n  return { path: '/', url: '/', params: {}, isExact: pathname === '/' };\n}\n\nexport default matchPath;\n"],"file":"match-path.js"}